# 챕터 02 넥스트의 기본 기능

## 2.1 넥스트에서 라우팅 하기

- 넥스트를 설치하면 pages 폴더를 이용하여 경로 설정 가능, pages 폴더에 파일을 만들면 파일의 경로에 따라 경로가 설정 

-  Link 컴포넌트를 import 하여 사용 가능, \<a> 태그외에 일반 태그들을 설정하는 경우, 라우팅 기능을 수행하짐나 웹 접근성과 SEO에 좋지 않다.

- 리액트 컴포넌트의 경우, \<a> 태그로 감싸 주어야 라우팅 기능을 사용 가능하다.

- 동적 페이지 라우팅을 하려면 다음과 같이 한다.

_pages/index.jsx_

```javascript
import Link from "next/link";

const App = () => {
    return (
        <div>
            <h2>Link to 'potato' Page</h2>
            <Link href="/vegetable/potato">
                <a>Move to '/vegetable/potato'</a>
            </Link>
        </div>
    );
};
```

_pages/[name].jsx_
```javascript
import Link from "next/link";
import { useRouter } from "next/router";

const name = () => {
    const router = useRouter();
    console.log(router);
    return (
        <div>
            <h2>Hello! </h2>
            <Link href="/">Move to '/'</Link>
        </div>
    )
}
```
> next의 파일 이름에서 Router 객체의 query 속성으로 들어가게된다. 


- 라우터 객체를 이용하여 라우팅 하기

_pages/index.jsx_

```javascript
import { useState } from "react";
import { useRouter } from "next/router";

const App = () => {
    const [name, setName] = useState("");
    const router = useRouter();

    return (
        <div>
            <button type="button" onClick={ () => router.push("/tomato") }> tomato로 가기
            </button>
            <p>이름</p>
            <input
                value={name}
                onChange={(e) => setName(e.target.value)}
                style={{ marginRight: "12px"}}
            />
            <button type="button" onClick={() => router.push(`/vegetable/${name}`) }>
        </div>
    );
};
export default App;
```

_pages/vegetable/[name].jsx_

```javascript
import Link from "next/link";
import { useRouter } from "next/router";

const name = () => {
    const { query } = useRouter();

    return (
        <div>
            <h2>Hello! {query.name} </h2>
            <Link href="/">Move to '/'</Link>
        </div>
    );
}
```

- 넥스트에서 라우팅 설정을 하고 주소 이동 하는 것을 해 보았다. 
  - 'pages' 폴더를 사용하여, 정적 페이지와 동적 페이지의 라우팅 설정 하였고, Link 컴포넌트와 라우터 객체를 이용하여 주소 이동을 할 수 있었다.


***

## 2.2 정적 파일 사용하기

- 넥스트에서 프로젝트 루트 경로로 'public' 폴더를 사용하여 정적 파일을 제공할 수 있다. 간단한 예제를 통하여 이미지 파일을 불러와 사용해 보도록 하자. 

```
/public
    /cheese.jpg
/pages
    /index.jsx    
```
> cheese.jpg 를 사용하려면 'public' 을 제외한 '/cheese.jpg' 를 사용하면 된다.


_pages/index.jsx_
```javascript
const App = () => (
    return (
        <div>
            <img src="/cheese.jpg" alt="치즈" />
        </div>
    );
)

export default App;
```
> 이미지 파일 이외에도 폰트, manifest.json, robots.txt, favicon.ico 등의 정적 파일을 제공할 때 유용하게 사용


***

## 2.3 서버로부터 데이터 불러오기

- 기본적으로 Next.js 는 모든 페이지를 미리 렌더링 한다. 미리 렌더링을 하여, html 을 생성하게 되면 더 나은 성능과 SEO 이점을 얻을 수 있다.

- 넥스트에는 두 가지 형태의 사전 렌더링이 존재한다.
    1) 정적 생성 : 빌드 시에 페이지를 HTML 로 만들어 요청 시 제공한다. 
   
    2) 서버 사이드 렌더링: 페이지 요청 시, 서버 사이드 렌더링을 통하여 HTML을 제공

- 외부 데이터를 필요로 하지 않는다면 넥스트는 빌드 시에 페이지를 렌더링하여 요청시마다 제공하게 된다.

- 외부 데이터를 필요로 한다면 서버 사이드 렌더링을 통하여, 외부 데이터를 이용하여 렌더링을 한 후 HTML을 제공하게 된다. 이때 서버 사이드 렌더링에 대하여 넥스트는 옵션을 제공하는데, 서버 사이드 렌더링 시 외부 데이터를 불러오는 법을 알아보고, 효율적인 HTML 을 제공하는 방법을 배워보자.

***

### 2.3.1 getServerSideProps

- 넥스트는 getServerSideProps 라는 페이지의 데이터를 서버로부터 제공받는 기본 API를 가지고 있다. 서버에서 데이터를 패치하여, 초기 데이터를 전달하도록 구성이 되어 있다.

- 서버에서 데이터를 패치하기 위해 다음의 모듈을 설치하자.

```
$ yarn add isomorphic-unfetch
```

- 깃허브 api 중 유저의 정보를 받아ㅇ는 api를 사용하고자 한다. api의 경로는 다음과 같다

```javascript
https://api.github.com/users/username
```

- 서버에서 데이터를 받아오는 코드를 작성한 후, 코드를 살펴보도록 하자.

_pages/index.jsx_
```javascript
import fetch from "isomorphic-unfetch";

const index = ({ user }) => {
    const username = user && user.name;
    return <div>{username}</div>;
};

export const getServerSideProps = async () => {
    try {
        const res = await fetch("https://api.github.com/users/jerrynim");
        if (res.status === 200) {
            const user = await res.json();
            return { props: { user } };
        }

    } catch (e) {
        console.log(e);
        return { props: {} };
    }
};

export default index;
```

- getServerSideProps 는 이름 그대로 서버 측에서 props 를 받아오는 기능을 하게 된다. 페이지를 요청 시 마다 실행이 되며, getServerSideProps 에서 페이지로 전달해 준 데이터를 서버에서 렌더링을 하게 된다. 서버에서 실행되기 때문에, 앞의 코드를 새로고침을 하여 실행해 본다면 콘솔 출력이 브라우저가 아닌 터미널에서 되는 것을 확인할 수 있다.

```javascript
try {
    const res = await fetch("https://api.github.com/users/jerrynim");
    if (res.status === 200) {
        const user = await res.json();
    }
} catch (e) {
    console.log(e);
    return {};
}
```
> 데이터 요청은 에러가 발생할 수 있기 떄문에 항상 try,catch 를 이용하자.

- 유저 정보를 불러오는데 성공했을 때에는 user 정보를 페이지에 props로 전달해 주고, 실패했다면 아무것도 전달해 주지 않게 하였다.

- getServerSideProps 에서 리턴한 rpops 값들은 페이지의 props 로 전달되게 된다. user 값이 undefined 일 수 있기에 다음과 같이 변수를 선언 하였다.

- getServerSideProps와 동적 라우팅을 이용하여 원하는 유저의 정보를 서버에서 불러오는 것을 해보도록 하자.

_pages/index.jsx_
```javascript
import React, { useState } from "react";
import Link from "next/link";

const App = () => {
    const [username, setUsername] = useState("");
    return (
        <div>
            <label>
                username
                <input value={username} onChange={(e) => setUsername(e.target.value)} />
            </label>
            <p>{username} 깃허브 검색하기</p>
            <Link href={`/users/${username}`}>
                <a>검색하기</a>
            </Link>
        </div>
    );
};

export default App;
```

- 검색하기를 클릭하게되면 입력된 쿼리로 전달하면 '/users/[name]' 페이지로 이동하게 될 것이다. 페이지를 불러올 때, 깃허브 유저의 정보를 불러오도록 하자.

_pages/users/[name].jsx_

```javascript
import fetch from "isomorphic-unfetch";

const name = ({ user }) => {
    const username = user && user.name;
    return <div>{username}</div>;
};

export const getServerSideProps = async ({ query }) => {
    const { name } = query;
    try {
        const res = await fetch(`https://api.github.com/users/${name}`);
        if (res.status === 200) {
            const user = await res.json();
            return { props: { user } };
        }
        return { props: {} };
    } catch(e) {
        console.log(e);
        return { props: {} };
    }
};

export default name;
```

***

### 2.3.2 getStaticProps